문제 유형: 자료구조, 시뮬레이션

## 문제 접근
가장 먼저 각 리그마다 정렬을 하며 양 끝, 중간값을 빠르게 찾아야 하므로 priority_queue(우선순위 큐)를 2개 사용하는 것을 고려했습니다. <br/>
하지만 양 끝에서 접근해야하므로 3개를 써야하나 싶다가, 한 queue에서 값을 꺼내면서 나머지 queue의 정합성을 관리하는 것은 $O(N)$이 들어 포기했습니다. <br/>

### set 자료구조 도입
set의 채택: set은 정렬을 지원하며, 양쪽 끝 원소(최대/최소)의 접근 및 삭제가 모두 $O(log N)$으로 가능합니다. <br/>
문제의 제약 조건 내에서 충분히 효율적이라 판단하여 set을 선택했습니다.

## 풀이 과정
각 리그를 두 개의 set으로 나누어 관리하는 아이디어를 적용했습니다. <br/>
insertP() 함수에서 새로운 선수가 추가될 때마다 l과 r의 크기 균형을 맞춥니다. <br/>
이를 통해 두 그룹의 경계가 항상 리그의 중앙값을 유지하도록 합니다. <br/>

## 시간 복잡도 계산

test case 당 0.1초 (10’000’000번)  <br/>  <br/>

### init()

- 리그 별 정렬
    - 리그 당 n = N/L(4’000)개
    - 리그 10개
    - O(nlogn) * 10 ⇒  4’000 * 12 * 10 = 480’000

### move() * 500

- n = (N/L)/2 = 2’000개
- 원소 접근
    - O(1)
        - priority queue (top()만 접근가능)
    - O(log n) ⇒ 11
        - tree set
        - tree map
    - move()당 원소 접근
- 원소 추가/삭제 및 정렬 유지
    - O(log n)
        - priority queue
        - tree set
        - tree map
- 9번의 교환
    - 교환 당 2번의 원소 접근, 삽입, 삭제
- 좌우 대칭 맞추기
    - 최악의 경우 교환 당 1번의 원소 접근, 삽입, 삭제

500 * O(log n) * 9 * 3 *3 = 500 * 900 = 450’000

### trade() * 1’000

move와 유사함

900’000

### 합계

25 * 1’800’000

= 45’000’000

= 450ms

실제로는 620ms

작은 테스트 -

객체 생성 및 복사 비용 +
