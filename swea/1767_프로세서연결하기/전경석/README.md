## 풀이 시간 22:00 ~ 23:10
* 설계 약 10분
* 구현 + 디버깅 약 1시간

## 사고 과정
* 문제 첫 느낌 - 그림만 봤을때 백준의 N-Queen 문제랑 비슷하다고 느낌 + input N 사이즈 보고 백트래킹이라고 판단.
* 시간복잡도 계산 => 각 코어마다 4개의 방향으로 전선 연결 => 4^12 = 16,777,216 이라고 판단.
* 코드 타이핑 도중, 전선을 연결하지 않는 경우도 체크해야 한다고 판단.
* 시간복잡도 다시 계산 => 5^12 = 244,140,625
* 60개 테스트케이스 이므로 60 * 5^12 = 14,648,437,500 ...?
* 근데 그냥 구현 함.
  * 이유 1. 다른 방법이 떠오르지 않음.
  * 이유 2. 테스트케이스 60개 중 극히 일부만 max case 일 것.
  * 이유 3. 백트래킹으로 구현했을때 시간이 그리 오래 걸릴 것 같지 않음.
_____


## 최적화 가능한 부분

* 현재 로직은 전선 연결한 부분을 -1로 바꾼 뒤, back() 함수 호출한 뒤에 다시 원상태로 복구하는 형태.
* 원상태로 복구하기 위해 List<Node>에 바꾼 노드의 좌표들을 저장하는데, 그러면 각 케이스(back 호출)마다 1개의 List가 생성되기 때문에 메모리 비효율적.
* 구현해보지는 않았지만, -1으로 변경하는 대신에, 각 함수마다 고유의 id값을 줘서 해당 값으로 변경하면 List에 저장하지 않고 원상태로 복구 가능할 듯. 


